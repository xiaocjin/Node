
## 为什么要异步I/O

#### 资源分配
>单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。多线程编程模型也因为变成中的死锁、状态同步等问题让开发人员头疼。Node在两者之间给出了答案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好的使用CPU。

## 异步I/O和非阻塞I/O
>任何技术都并非完美。阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完成数据获取，它会让CPU处理状态判断，是对CPU的浪费。轮询技术满足了非阻塞I/O去报获取完整数据的需求，但对于应用程序而言，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回。

>我们期待的完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或者回调将数据传递给应用程序即可。

>现实的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询。但是它的内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。

>我们常常提到Node是单线程的，这里的单线程仅仅是javascript执行在单线程中罢了。在Node中，内部完成I/O任务的另有线程池。

## Node的异步I/O
  
  完成整个异步I/O环节的有事件循环、观察者和请求对象等。
  
#### 事件轮询
>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的称成为Tick。每个Tike的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程

#### 观察者
>在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。

>事件循环还是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。

#### 请求对象

>事实上，从Javascript发起调用到内核执行完I/O操作的过程中，存在一种中间产物，它叫做请求对象。从Javascript层传入的参数和当前方法都被封装在这个请求对象中。Javascript调用立即返回，由Javascript层面发起的异步调用的第一阶段就此结束。Javascript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到Javascript的后续执行，如此就达到了异步的目的。

#### 执行回调

>在每次Tick的执行中，它会调用对应方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O对象观察者的队列中，然后将其当作事件处理。

>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。

## 非I/O的异步API

#### 定时器

#### process.nextTick()

#### setImmediate()

## 总结
>事件循环是异步实现的核心，Node依靠构建了一套完善的高性能异步I/O框架，打破了Javascript在服务器端止步不前的局面。
